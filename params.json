{"name":"Building an Unbeatable Tic Tac Toe Player","tagline":"Lessons from my second week learning Python","body":"In week 2 at the Iron Yard, our instructor, Joel Taddei, gave us a fun weekend challenge - build a Tic Tac Toe player. On Monday, he would pit our Tic Tac Toe \"bots\" together in hundreds of simulations to determine a champion. Here's how I approached the problem and built an unbeatable bot. I really got to dig deep into control coding and understand how to build complex functions, while having some fun along the way. \r\n\r\n### Building a Game Board and Simulator\r\nOur instructor provided us a game board and built the code to run simulations while also allowing for an individual to play a bot. This is located in the runner.py file on Github. \r\n\r\n### How to Run Play or Run Simulations\r\nAfter downloading the Github code, run `python runner.py first_bot_name.py second_bot_name.py` to simulate a game. You can also substitute a .py file for `player` to play as yourself. The game board will look as such:\r\n\r\n<img src=https://cloud.githubusercontent.com/assets/14279088/12205217/7cf5ceb2-b5f6-11e5-8b41-a6fc0c0d3d12.png>\r\n\r\nThe first bot or player entered will go first. If you are playing yourself, an example move would be _A1_. On to the code...\r\n\r\n###Step 1: Creating a Game Board for the AI to Read\r\n\r\nThe below code establishes a self.me and self.opponent (the first player always has X in the simulations). The first, second, and third row were provided to us by input(), but I manually created columns, diagonals, corners, and middle edge positions for my bot to have more understanding of the board. In my code, I refer to the various tic tac toe spaces as such:\r\n\r\n<img src=https://cloud.githubusercontent.com/assets/14279088/12206019/d8e07556-b5fb-11e5-9853-8d26d34e82ae.png>\r\n\r\nBy these coordinates, `first_row[0]` refers to the top left corner, `first_row[1]` is the middle spot in the first row, and `first_row[2]` is the top right corner.\r\n\r\n    class Bot:\r\n\r\n      def board(self):\r\n        self.me = input()\r\n        if self.me == \"X\":\r\n            self.opponent = \"O\"\r\n        else:\r\n            self.opponent = \"X\" \r\n        \r\n        self.first_row = input()\r\n        self.second_row = input()\r\n        self.third_row = input()\r\n        self.first_column = self.create_column(0, 0, 0)\r\n        self.second_column = self.create_column(1, 1, 1)\r\n        self.third_column = self.create_column(2, 2, 2)\r\n        self.left_right_diagonal = self.create_column(0, 1, 2)\r\n        self.right_left_diagonal = self.create_column(2, 1, 0)\r\n        self.corners = self.first_row[0], self.first_row[2], self.third_row[0], self.third_row[2]\r\n        self.positions = [item for sublist in self.game_board for item in sublist]\r\n        self.positions_taken = self.positions.count(\"X\") + self.positions.count(\"O\")\r\n        self.middles = self.first_row[1], self.second_row[0], self.second_row[2], self.third_row[1]\r\n\r\n        self.game_board = self.create_board(self.first_row, self.second_row, self.third_row)\r\n\r\n        return self.game_board\r\n\r\n      def create_board(self, first_row, second_row, third_row):\r\n        return [self.first_row, self.second_row, self.third_row]\r\n\r\n      def create_column(self, x, y, z):\r\n        return [self.first_row[x], self.second_row[y], self.third_row[z]]\r\n\r\n###Overall Strategy \r\nAs silly as it sounds, I performed a good deal of research into tic tac toe strategy while playing hundreds of games online. There are many good articles, youtube videos, and even academic research papers into proper strategy. Strategy must be separated into going first and going second. When going first, the goal should always be to take advantage and defeat the opponent. However, the goal when going second against great players should be to simply tie. It is possible to force a tie every time when going second - thus, as long as your opponent also isn't using optimum strategy, at least a few wins going first will give you the overall edge. This defensive strategy worked perfectly for me. \r\n\r\nI discovered through a combination of research and trial/error that it is only necessary to hard code the first two moves of a tic tac toe game in order to play optimal strategy. This allowed me to build an unbeatable bot with relatively little code and complexity. I would create the following play hierarchy, each move with it's own function in my bot class:\r\n\r\n* Check for first move\r\n* Check for second move\r\n* Check for win\r\n* Check for block\r\n* Check for corner move\r\n* Move in random empty square (only occurs when a tie is inevitable)\r\n\r\n-\r\n    def make_move(self):\r\n        counter = 0\r\n        while counter < 0.5:\r\n            if self.first_move() != False:\r\n                counter = 1\r\n            elif self.second_move() != False:\r\n                counter = 1\r\n            elif self.get_win() != False:\r\n                counter = 1\r\n            elif self.block_win() != False:\r\n                counter = 1\r\n            elif self.corner_move() != False:\r\n                counter = 1\r\n            else:\r\n                x = random.randint(0,2)\r\n                y = random.randint(0,2)\r\n                z = self.game_board[x][y]\r\n                if z != \"X\" and z != \"O\":\r\n                    print((\"{} {}\".format(x, y)))\r\n                    counter = 1\r\n                else:\r\n                    counter = 0\r\n\r\n###First Move\r\nThe strategy is as follows:\r\n* If moving first:\r\n    * Keep it simple, take a corner. This provides for the most win opportunities moving forward in the game.\r\n* If moving second:\r\n    * If the opponent is in a corner -- move middle\r\n    * If the opponent is taking a middle edge -- move middle \r\n    * Otherwise -- move corner (optimal situation)\r\n\r\n-\r\n    def first_move(self):\r\n        if self.me not in self.first_row and self.me not in self.second_row and self.me not in self.third_row:\r\n            if self.opponent in self.first_row or self.opponent in self.second_row or self.opponent in self.third_row:\r\n                if self.opponent in self.corners:\r\n                    print(1,1)\r\n                elif self.opponent in self.middles:\r\n                    print(1,1)\r\n                else:\r\n                    print(0,0)\r\n            else:\r\n                print(0,0)\r\n        else:\r\n            return False\r\n\r\n###Second Move\r\nThe second move turned out to be the most complicated, because at this point the opponent has established their strategy and you must account for every potential scenario.\r\n\r\n* If moving first:\r\n    * If opponent took middle on their first move -- take opposite corner than you previously took to create a diagonal through the middle space. This creates the most opportunities for wins, and you've automatically won if your opponent does not force a block next turn.\r\n\r\n<img src=https://cloud.githubusercontent.com/assets/14279088/12206695/9962cc18-b5ff-11e5-8337-dc78c52d1b15.png>\r\n\r\n   * Otherwise, choose any open corner.\r\n* If moving second (i.e. opponent already owns two spaces):\r\n    * If opponent has two corners, force a block by taking a middle edge space:\r\n\r\n<img src=https://cloud.githubusercontent.com/assets/14279088/12206913/e2896ab8-b600-11e5-9ad5-6bae5c81107e.png>\r\n\r\n   * If opponent has a corner and a middle edge, then you must account for every potential combination. Don't worry, this is the last specific move that you'll need to hard code or remember for the rest of the game. First, you want to choose the square giving you a potential winning diagonal. Since there are two of these squares, you want the square _next to_ to the opponent's middle edge, or in the middle of their \"L\" shape. This takes away their win strategy while forcing their hand to block next turn.\r\n\r\n* In all other scenarios, take any empty corner.\r\n\r\n-\r\n    def second_move(self):\r\n        if self.positions_taken == 2:\r\n            if self.second_row[1] == self.opponent:\r\n                print(2,2)\r\n                counter = 1\r\n            else:\r\n                return False\r\n        elif self.positions_taken == 3:\r\n            if self.corners.count(self.opponent) == 2:\r\n                x = 1\r\n                y = random.choice([0, 2])\r\n                z = self.game_board[x][y]\r\n                if z != \"X\" and z != \"O\":\r\n                    print((\"{} {}\".format(x, y)))\r\n                    counter = 1\r\n                else:\r\n                    counter = 0\r\n            elif self.middles.count(self.opponent) == 1 and self.corners.count(self.opponent) == 1:\r\n                if self.opponent in self.first_row[0]:\r\n                    if self.opponent in self.second_row[2]:\r\n                        print(0,2)\r\n                    elif self.opponent in self.third_row[1]:\r\n                        print(2,0)\r\n                    else:\r\n                        return False\r\n                elif self.opponent in self.first_row[2]:\r\n                    if self.opponent in self.first_column[1]:\r\n                        if self.me not in self.first_row[0]:\r\n                            print(0,0)\r\n                        else:\r\n                            print (1,1)\r\n                    elif self.opponent in self.second_column[2]:\r\n                        print(2,2)\r\n                    else:\r\n                        return False\r\n                elif self.opponent in self.third_row[0]:\r\n                    if self.opponent in self.second_column[0]:\r\n                        if self.me not in self.first_row[0]:\r\n                            print(0,0)\r\n                        else:\r\n                            print(1,1)\r\n                    elif self.opponent in self.third_column[1]:\r\n                        print(2,2)\r\n                    else:\r\n                        return False\r\n                elif self.opponent in self.third_row[2]:\r\n                    if self.opponent in self.second_column[0]:\r\n                        print(0,2)\r\n                    elif self.opponent in self.first_column[1]:\r\n                        print(2,0)\r\n                    else:\r\n                        return False\r\n                else:\r\n                    return False\r\n            else:\r\n                return False\r\n        else:\r\n            return False\r\n\r\nFrom here on out it's easy! 1) Check for any wins, 2) make sure to block any opponent wins, 3) Keep taking empty corners (in this order). You've guaranteed a win or a draw.\r\n\r\n    def get_win(self):\r\n        if self.first_row.count(self.me) == 2 and self.first_row.count(\"_\") == 1:\r\n            y = self.first_row.index(\"_\")\r\n            print(0, y)\r\n        elif self.second_row.count(self.me) == 2 and self.second_row.count(\"_\") == 1:\r\n            y = self.second_row.index(\"_\")\r\n            print(1, y)\r\n        elif self.third_row.count(self.me) == 2 and self.third_row.count(\"_\") == 1:\r\n            y = self.third_row.index(\"_\")\r\n            print(2, y)\r\n        elif self.first_column.count(self.me) == 2 and self.first_column.count(\"_\") == 1:\r\n            x = self.first_column.index(\"_\")\r\n            print(x, 0)\r\n        elif self.second_column.count(self.me) == 2 and self.second_column.count(\"_\") == 1:\r\n            x = self.second_column.index(\"_\")\r\n            print(x, 1)\r\n        elif self.third_column.count(self.me) == 2 and self.third_column.count(\"_\") == 1:\r\n            x = self.third_column.index(\"_\")\r\n            print(x, 2)\r\n        elif self.left_right_diagonal.count(self.me) == 2 and self.left_right_diagonal.count(\"_\") == 1:\r\n            x = self.left_right_diagonal.index(\"_\")\r\n            if x == 0:\r\n                y = 0\r\n            if x == 1:\r\n                y = 1\r\n            if x == 2:\r\n                y = 2\r\n            print(x, y)\r\n        elif self.right_left_diagonal.count(self.opponent) == 2 and self.right_left_diagonal.count(\"_\") == 1:\r\n            x = self.right_left_diagonal.index(\"_\")\r\n            if x == 0:\r\n                y = 2\r\n            if x == 1:\r\n                y = 1\r\n            if x == 2:\r\n                y = 0\r\n            print(x, y)\r\n        else:\r\n            return False\r\n\r\n    def block_win(self):\r\n        if self.first_row.count(self.opponent) == 2 and self.first_row.count(\"_\") == 1:\r\n            y = self.first_row.index(\"_\")\r\n            print(0, y)\r\n        elif self.second_row.count(self.opponent) == 2 and self.second_row.count('_') == 1:\r\n            y = self.second_row.index(\"_\")\r\n            print(1, y)\r\n        elif self.third_row.count(self.opponent) == 2 and self.third_row.count(\"_\") == 1:\r\n            y = self.third_row.index(\"_\")\r\n            print(2, y)\r\n        elif self.first_column.count(self.opponent) == 2 and self.first_column.count(\"_\") == 1:\r\n            x = self.first_column.index(\"_\")\r\n            print(x, 0)\r\n        elif self.second_column.count(self.opponent) == 2 and self.second_column.count(\"_\") == 1:\r\n            x = self.second_column.index(\"_\")\r\n            print(x, 1)\r\n        elif self.third_column.count(self.opponent) == 2 and self.third_column.count(\"_\") == 1:\r\n            x = self.third_column.index(\"_\")\r\n            print(x, 2)\r\n        elif self.left_right_diagonal.count(self.opponent) == 2 and self.left_right_diagonal.count(\"_\") == 1:\r\n            x = self.left_right_diagonal.index(\"_\")\r\n            if x == 0:\r\n                y = 0\r\n            if x == 1:\r\n                y = 1\r\n            if x == 2:\r\n                y = 2\r\n            print(x, y)\r\n        elif self.right_left_diagonal.count(self.opponent) == 2 and self.right_left_diagonal.count(\"_\") == 1:\r\n            x = self.right_left_diagonal.index(\"_\")\r\n            if x == 0:\r\n                y = 2\r\n            if x == 1:\r\n                y = 1\r\n            if x == 2:\r\n                y = 0\r\n            print(x, y)\r\n        else:\r\n            return False\r\n\r\n    def corner_move(self):\r\n        if self.corners.count(\"_\") < 4 and self.corners.count(\"_\") > 0:\r\n            count = 0\r\n            while count < .05:\r\n                x = random.choice([0, 2])\r\n                y = random.choice([0, 2])\r\n                z = self.game_board[x][y]\r\n                if z != \"X\" and z != \"O\":\r\n                    print((\"{} {}\".format(x, y)))\r\n                    count = 1\r\n                    counter = 1\r\n                else:\r\n                    count = 0\r\n        else:\r\n            return False\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}